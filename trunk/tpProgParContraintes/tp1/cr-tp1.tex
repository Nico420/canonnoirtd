% !TEX TS-program = pdflatex
% !TEX encoding = UTF-8 Unicode

% This is a simple template for a LaTeX document using the "article" class.
% See "book", "report", "letter" for other types of document.

\documentclass[11pt]{article} % use larger type; default would be 10pt

\usepackage[utf8]{inputenc} % set input encoding (not needed with XeLaTeX)
\usepackage[T1]{fontenc}
\usepackage{times}

\usepackage{graphicx} % support the \includegraphics command and options

\usepackage[francais]{babel}

\usepackage{listings}

\usepackage{url}

\usepackage{rotating}

\usepackage[a4paper]{geometry}


\date{\today}

\title{Rapport Travaux Pratiques : \\Acquisition de connaissance 2\\ - TP 2: \\Programmation Logique Inductive}
\author{Nicolas Desfeux\\Aurélien Texier}
\begin{document}
\lstset{language=Prolog,breaklines=true,numbers=left,basicstyle=\footnotesize ,numberstyle=\footnotesize}
\maketitle
\tableofcontents
\newpage
\section{Prise en main  Les trains de Michalsky}
\begin{figure}
\includegraphics[width=15cm]{tp1.png}
\caption{Arbre Prolog 1}
\end{figure}
\lstinputlisting[caption="test"]{tp1}

Question 1.2

/* Il parcourt les branches de l'arbre des possibilités et il coupe les branches qui ne
s'unifient pas avec les contraintes.
Il s'arrête quand il a parcouru toutes les possibilités, et donc il génère toutes les solutions possibles,
toutes celles qui remplissent les contraintes.
*/

test commande : 
Le temps de réponse n'est pas négligeable puisqu'il est de 7.73 secondes.
En utilisant la trace de l'exécution, on constate que l'on est ici dans un contexte de "Generate and Test",
qui est dans ce cas beaucoup plus coûteux en temps.
Il génère les solutions qui sont dans les intervalles données (il y en a beaucoup !),
puis il teste celles qui remplissent la condition >=.
Comme on peut le constater dans le dessin de l'arbre de recherche Porlog ci-joint, Prolog rencontre
dans son arbre de recherche beaucoup d'échecs puisqu'il génère tout, et c'est cela la cause de la perte de
beaucoup de temps d'exécution.


 On réitère l'essai mais en mettant le prédicat >= avant le isBetween.
test commandebis : 

Nous sommes ici dans un cas de figure de "Constraints and Generate"
On voit alors ici que Prolog ne peut pas trouver de solution car pour remplir la condition
sur le >=, il y a une infinité de solutions puisqu'il ne sait pas encore dans quel intervalle travailler.
Donc il nous répond qu'il y a une faute d'instanciation.
Dans le cas d'avant, le isBetween permettait de lui donner un nombre fini de solutions pour les deux variables,
et après il pouvait alors trouver les solutions qui remplissaient le >=.
Nous sommes pour le commandeBis dans un cas de figure de "Generate and Test", puisqu'il génère les solutions sans
regarder ce qu'il a après comme condition.

test commande 2 :
Ici, la réponse d'eclipse est que les intervalles réponses pour les 2 variables sont
[9000,10000].

test commande 3 :
Ici, on voit clairement que le temps de réponse est vraiment plus rapide (moins d'un centième de seconde),
et ceci est dû au fait que le labeling, à savoir le solveur ic, regarde toutes les contraintes avant de
générer les solutions. Ce qui signifie qu'ici, il a réduit à l'avance les intervalles de solutions minimales
avant de générer les réponses. C'est un gain de temps énorme pour le cas ici présent puisque l'arbre de recherche
de Prolog (dessiné ci-joint) ne rencontre jamais d'échecs car il se construit dans les bonnes intervalles.

test chapie : 
Il faut donc 3 pies et 14 pattes pour totaliser 5 têtes et deux chats.

1.10 : 
Ici, il y a donc une infinité de solutions. La première donnée par le solveur est
{0,0,0,0} puis {1,1,6,2}, etc.

vabs : 
Les deux prédicats ont ici exactement la même attitude pour ce cas de figure.

vabs2 : 
Ici, seul la première version du prédicat donne les deux résultats corrects attendus.

 Question 1.12

/* Tests
Nous n'afficherons pas les tests car ils prennent de la place.
Pour la première version du prédicat, cela donne bien toutes les solutions possibles,
d'abord pour les X positifs puis pour les négatifs.
Pour la deuxième version, le prédicat donne d'abord les solution {0,0}, puis les solutions
négatives pour X, puis les positives.

*/

faitListe : 
Logique, 1 n'est pas entre Min et Max !

dim : 
Cette requête permet de visualiser les suites formées par le prédicat avec les 2 premiers
éléments de cette suite compris entre 1 et 10. Effectivement, il semble y avoir périodicité entre le premier
et le dixième élément (et donc une période de 9).

Requête vérifiant que la suite est périodique de période 9
(vérifie qu'il n'existe aucune suite L ayant son premier et son dixième élément différents avec les deux premiers
éléments de la suite compris entre 1 et 10)

Prolog répond bien non à cette requête. On réitère alors avec les deux premiers éléments de la suite compris
entre 1 et 100.

La réponse est toujours non.
Enfin, on essaie avec les deux premiers éléments de la suite compris entre 1 et 1000.
Après plus d'une minute, Prolog répond toujours non.

Pour conclure, dans le prédicat suite, on remarquera que l'on est dans de la propagation et non du backtracking
puisque l'on construit la suite au fur et à mesure du parcourt de l'arbre à l'exécution.
Il n'y a donc pas besoin de faire appel au prédicat labeling.
\end{document}
