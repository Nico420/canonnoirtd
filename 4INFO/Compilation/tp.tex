% !TEX TS-program = pdflatex
% !TEX encoding = UTF-8 Unicode

% This is a simple template for a LaTeX document using the "article" class.
% See "book", "report", "letter" for other types of document.

\documentclass[11pt]{article} % use larger type; default would be 10pt

\usepackage[utf8]{inputenc} % set input encoding (not needed with XeLaTeX)
\usepackage[T1]{fontenc}
\usepackage{times}

\usepackage{graphicx} % support the \includegraphics command and options

\usepackage[francais]{babel}

\usepackage{listings}

\usepackage{url}

\usepackage{rotating}

\usepackage[a4paper]{geometry}


\date{\today}

\title{Rapport Compilation - TP 2 : \\Analyse syntaxique descendante}
\author{Nicolas Desfeux\\Renaud Philippe}
\begin{document}
\lstset{language=Caml,breaklines=true,numbers=left}
\maketitle
\tableofcontents
\section{Mise en forme de la grammaire}
Lors du pr\'ec\'edent TP, nous avons utilis\'e une grammaire qui n'est pas adapt\'e à l'analyse syntaxique.
\subsection{Adaptation de la grammaire}
Pour pouvoir utiliser la grammaire pour cr\'eer l'analyseur syntaxique, nous avons du lui apporter les modifications suivantes : 
\begin{itemize}
	\item Supression des r\`egles qui ne concernent pas l'analyse syntaxique.
	\item Supression des expressions r\'eguli\`ere.
\end{itemize}
	Nous allons donc travailler avec la grammaire suivante : 
\begin{lstlisting}
<Expr>		--> <Termb> <SuiteExpr>
<SuiteExpr>	--> "ou" <Termb> <SuiteExpr> | Epsilon

<Termb>		--> <Facteurb> <SuiteTermb>
<SuiteTermb>	--> "et" <Facteurb> <SuiteTermb> | Epsilon

<Facteurb>	--> <Relation> | "(" <Expr> ")" | "si" <Expr> "alors"
			<Expr> "sinon" <Expr> "fsi"
<Relation>	--> <Ident> <Op> <Ident>

<Op>		--> "=" | "<>" | "<" | ">" | ">=" | "<="
\end{lstlisting} 
\subsection{D\'emonstration du caract\`ere LL(1)}
Pour prouver que cette grammaire est LL(1), nous avons utliser le corollaire vu en cours.\\
Il nous faut étudier chaque règles, et pour chacune d'elle vérifier les conditions suivantes : 
\begin{itemize}
\item Les intersections des ensembles de premiers des parties droites de la règle sont premiers deux à deux.
\item Si null(règle), alors l'intersection des ensembles premier et suivant de la partie gauche de la règle doit être vide.
\item Si null(règle), alors il existe un unique chemin qui de la partie gauche de la règle mène à epsilon.
\end{itemize}
On étudie donc chaque règle de notre grammaire : 
\begin{enumerate}
\item[<Expr>] La partie droite de la règle ne contient qu'un seul élément, elle vérifie donc la première condition. On a !null(<Expr>), et donc cette règle vérifie donc les trois conditions.
\item[<SuiteExpr>] La partie droite de la règle un élément et epsilon, l'intersection des ensemble de premier sera donc vide, puisque premier(epsilon)=\{\}. Elle vérifie donc la première condition. On a null(<SuiteExpr>). premier(<SuiteExpr>) = \{"ou"\} et suivant(<SuiteExpr>)=epsilon, la seconde condition est donc respectée. Il n'y a qu'un seul chemin pour accéder à epsilon, la troisième condition est donc respecté. Cette règle vérifie donc les trois conditions.
\item[<Termb>] La partie droite de la règle ne contient qu'un seul élément, elle vérifie donc la première condition. On a !null(<Termb>), et donc cette règle vérifie donc les trois conditions.
\item[<SuiteTermb>] La partie droite de la règle un élément et epsilon, l'intersection des ensemble de premier sera donc vide, puisque premier(epsilon)=\{\}. Elle vérifie donc la première condition. On a null(<SuiteExpr>). premier(<SuiteTermb>) = \{"et"\} et suivant(<SuiteTermb>)=epsilon, la seconde condition est donc respectée. Il n'y a qu'un seul chemin pour accéder à epsilon, la troisième condition est donc respecté. Cette règle vérifie donc les trois conditions.
\item[<Facteurb>] premier(<Relation>)={<Lettre>}\\
premier("(" <Expr> ")")={"("}\\
premier("si" <Expr> "alors" <Expr> "sinon" <Expr> "fsi")={"si"}\\
Toutes les intersections des ensembles de premiers sont vides deux à deux. Cette règle vérifie donc la première condition. On a !null(<Facteurb>), et donc cette règle vérifie donc les trois conditions.
\item[<Relation>] La partie droite de la règle ne contient qu'un seul élément, elle vérifie donc la première condition. On a !null(<Relation>), et donc cette règle vérifie donc les trois conditions.

\item[<Op>] La partie droite de cette règle n'est constitué que de non terminaux, tous différents. L'intersection des ensembles premiers sera donc vide. On a !null(<Op>), et donc cette règle vérifie donc les trois conditions.
\end{enumerate}
Toutes les règles respectent les conditions du corollaire, on peut donc en déduire que \\
	\begin{center}
		\textbf{La grammaire est LL(1)}.
	\end{center}

\section{Implémentation de l'analyse syntaxique descendante}
\subsection{Code de notre analyseur}
\lstinputlisting[caption=Analyseur syntaxique descendant déterministe]{Asdd.ml}
\subsection{Test}
Nous avons testé plusieurs expressions pour notre analyseur, afin de vérifier son bon fonctionnement, et regarder son comportement en cas d'erreur.
Voici les tests que nous avons pratiqué : 
\begin{lstlisting}
let vlist = [VN Expr];;
let ullist= [U_ident;U_sup;U_ident;U_et;U_paro;U_ident;U_eg;U_ident;U_parf;U_eof];;

let arbre = analyse_mot(vlist,ullist);;

let vlist2 = [VN Expr];;
let ullist2= [U_ident;U_ident;U_et;U_paro;U_ident;U_eg;U_ident;U_parf];;

let arbre 2 analyse_mot(vlist2,ullist2);;

\end{lstlisting}
Normalement, arbre devrait être correct, et nous devrions avoir une erreur avec arbre2. Et c'est effectivement ce que notre analyseur va produire : 
\begin{lstlisting}
#     val vlist : v list = [VN Expr]
# val ullist : Lex.unite_lexicale list =
  [U_ident; U_sup; U_ident; U_et; U_paro; U_ident; U_eg; U_ident; U_parf;
   U_eof]
#   val arbre : arbre_concret list * Lex.unite_lexicale list =
  ([Noeud
     (Expr,
      [Noeud
        (Termb,
         [Noeud
           (Facteurb,
            [Noeud
              (Relation,
               [Feuille Vt_ident; Noeud (Op, [Feuille Vt_sup]);
                Feuille Vt_ident])]);
          Noeud
           (SuiteTermb,
            [Feuille Vt_et;
             Noeud
              (Facteurb,
               [Feuille Vt_parg;
                Noeud
                 (Expr,
                  [Noeud
                    (Termb,
                     [Noeud
                       (Facteurb,
                        [Noeud
                          (Relation,
                           [Feuille Vt_ident; Noeud (Op, [Feuille Vt_eg]);
                            Feuille Vt_ident])]);
                      Noeud (SuiteTermb, [])]);
                   Noeud (SuiteExpr, [])]);
                Feuille Vt_pard]);
             Noeud (SuiteTermb, [])])]);
       Noeud (SuiteExpr, [])])],
   [U_eof])
#     val vlist2 : v list = [VN Expr]
# val ullist2 : Lex.unite_lexicale list =
  [U_ident; U_ident; U_et; U_paro; U_ident; U_eg; U_ident; U_parf]
#   Exception: Etat_incorrect "Mauvais ul".
\end{lstlisting}

Nous avons ensuite testé la création des arbres syntaxiques abstrait, et cela fonctionne correctement. Voici le résultat que nous obtenons.
\begin{lstlisting}
val a : arbre_concret =
  Noeud
   (Expr,
    [Noeud
      (Termb,
       [Noeud
         (Facteurb,
          [Noeud
            (Relation,
             [Feuille (Vt_ident "t"); Noeud (Op, [Feuille Vt_sup]);
              Feuille (Vt_ident "y")])]);
        Noeud
         (SuiteTermb,
          [Feuille Vt_et;
           Noeud
            (Facteurb,
             [Feuille Vt_parg;
              Noeud
               (Expr,
                [Noeud
                  (Termb,
                   [Noeud
                     (Facteurb,
                      [Noeud
                        (Relation,
                         [Feuille (Vt_ident "x");
                          Noeud (Op, [Feuille Vt_eg]);
                          Feuille (Vt_ident "y")])]);
                    Noeud (SuiteTermb, [])]);
                 Noeud (SuiteExpr, [])]);
              Feuille Vt_pard]);
           Noeud (SuiteTermb, [])])]);
     Noeud (SuiteExpr, [])])
val b : Lex.unite_lexicale list = [U_eof]
# - : arbre_abstrait =
Expr_et (Relations ("t", Op_sup, "y"), Relations ("x", Op_eg, "y"))
\end{lstlisting}

Le résultat obtenu correspond donc au résultat attendu.\\
Autre test : \\
\begin{lstlisting}
val vlist3 : v list = [VN Expr]
val ullist3 : Lex.unite_lexicale list =
  [U_ident "a"; U_infeg; U_ident "b"; U_ou; U_paro; U_ident "x"; U_supeg;
   U_ident "b"; U_ou; U_ident "x"; U_inf; U_ident "a"; U_parf; U_eof]
val arb : arbre_concret =
  Noeud
   (Expr,
    [Noeud
      (Termb,
       [Noeud
         (Facteurb,
          [Noeud
            (Relation,
             [Feuille (Vt_ident "a"); Noeud (Op, [Feuille Vt_infeg]);
              Feuille (Vt_ident "b")])]);
        Noeud (SuiteTermb, [])]);
     Noeud
      (SuiteExpr,
       [Feuille Vt_ou;
        Noeud
         (Termb,
          [Noeud
            (Facteurb,
             [Feuille Vt_parg;
              Noeud
               (Expr,
                [Noeud
                  (Termb,
                   [Noeud
                     (Facteurb,
                      [Noeud
                        (Relation,
                         [Feuille (Vt_ident "x");
                          Noeud (Op, [Feuille Vt_supeg]);
                          Feuille (Vt_ident "b")])]);
                    Noeud (SuiteTermb, [])]);
                 Noeud
                  (SuiteExpr,
                   [Feuille Vt_ou;
                    Noeud
                     (Termb,
                      [Noeud
                        (Facteurb,
                         [Noeud
                           (Relation,
                            [Feuille (Vt_ident "x");
                             Noeud (Op, [Feuille Vt_inf]);
                             Feuille (Vt_ident "a")])]);
                       Noeud (SuiteTermb, [])]);
                    Noeud (SuiteExpr, [])])]);
              Feuille Vt_pard]);
           Noeud (SuiteTermb, [])]);
        Noeud (SuiteExpr, [])])])
val reste : Lex.unite_lexicale list = [U_eof]
# - : arbre_abstrait =
Expr_ou (Relations ("a", Op_infeg, "b"),
 Expr_ou (Relations ("x", Op_supeg, "b"), Relations ("x", Op_inf, "a")))
\end{lstlisting}
Le résultat correspond tout à fait à ce que l'on attend.\\
\\ 
Nous n'avons malheureusement pas eu le temps d'implémenter la gestion des cas d'erreur pour la construction des arbres concret.

\subsection{Questions de compréhension}
\paragraph{Question 2.1} Si on incluait les commentaires dans la grammaire définissant les constructions du langage, elle ne serait plus déterministe.
\paragraph{Question 2.2} Nous n'avons ici pas besoin de pile dans l'implémentation car Ocaml possède déjà une pile, et c'est de celle là qu'il va se servir pour l'automate à pile.
\paragraph{Question 2.3} Une grammaire LL(1) permet la création d'un analyseur syntaxique descendant car cela nous assure que la grammaire est sans ambiguïté. S'il y avait la moindre ambiguïté, il serait impossible pour notre grammaire de choisir la bonne règle. On a donc l'assurance de choisir la seule règle possible car il n'y a qu'un seul choix à chaque fois.
\paragraph{Question 2.4} L'arbre abstrait, lié à une syntaxe abstraite, est beaucoup plus utile pour l'analyse syntaxique que l'arbre concret. L'arbre concret va donner une représentation externe de la structure de l'arbre, tandis que l'arbre abstrait donne une structure plus profonde de l'arbre.L C'est de cette structure plus profonde dont nous avons besoin pour l'analyse syntaxique descendante de l'arbre.
\end{document}
